"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url = __importStar(require("url"));
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const pipcook_core_1 = require("@pipcook/pipcook-core");
const realOra = require("ora");
exports.Constants = {
    BOA_CONDA_INDEX: 'https://pypi.tuna.tsinghua.edu.cn/simple',
    BOA_CONDA_MIRROR: 'https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda'
};
exports.cwd = process.cwd;
function execAsync(cmd, opts) {
    return new Promise((resolve, reject) => {
        child_process_1.exec(cmd, opts, (err, stdout) => {
            err == null ? resolve(stdout) : reject(err);
        });
    });
}
exports.execAsync = execAsync;
function execNpm(subcmd, flags, opts) {
    return new Promise((resolve, reject) => {
        const cli = child_process_1.spawn('npm', [subcmd, flags], Object.assign({ stdio: 'inherit', env: process.env }, opts));
        cli.on('exit', resolve);
        cli.on('error', reject);
    });
}
exports.execNpm = execNpm;
function tail(id, name) {
    return child_process_1.spawn('tail', [
        '-f',
        `${pipcook_core_1.constants.PIPCOOK_HOME_PATH}/components/${id}/logs/${name}.log`
    ], {
        stdio: 'inherit'
    });
}
exports.tail = tail;
function parseConfigFilename(filename) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!filename) {
            throw new TypeError('Please specify the config path');
        }
        let urlObj = url.parse(filename);
        // file default if the protocol is null
        if (urlObj.protocol == null) {
            filename = path_1.default.isAbsolute(filename) ? filename : path_1.default.join(process.cwd(), filename);
            // check the filename existence
            if (!(yield fs_extra_1.pathExists(filename))) {
                throw new TypeError(`${filename} not exists`);
            }
            else {
                filename = url.parse(`file://${filename}`).href;
            }
        }
        else if (['http:', 'https:'].indexOf(urlObj.protocol) === -1) {
            throw new TypeError(`protocol ${urlObj.protocol} is not supported`);
        }
        return filename;
    });
}
exports.parseConfigFilename = parseConfigFilename;
class TtyLogger {
    constructor() {
        this.spinner = realOra({ stream: process.stdout });
    }
    success(message) {
        this.spinner.succeed(message);
    }
    fail(message, exit = true, code = 1) {
        this.spinner.fail(message);
        if (exit) {
            process.exit(code);
        }
    }
    info(message) {
        this.spinner.info(message);
    }
    warn(message) {
        this.spinner.warn(message);
    }
    start(message) {
        this.spinner.start(message);
    }
}
class DefaultLogger {
    success(message) {
        console.log('[success]: ' + message);
    }
    fail(message, exit = true, code = 1) {
        console.error('[fail]: ' + message);
        if (exit) {
            process.exit(code);
        }
    }
    info(message) {
        console.log('[info]: ' + message);
    }
    warn(message) {
        console.warn('[warn]: ' + message);
    }
    start(message) {
        console.log('[start]: ' + message);
    }
}
const { rows, columns, isTTY } = process.stdout;
exports.logger = isTTY && rows > 0 && columns > 0 ? new TtyLogger() : new DefaultLogger();
//# sourceMappingURL=utils.js.map