#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = __importDefault(require("commander"));
const path = __importStar(require("path"));
const pipeline_1 = require("../pipeline");
const request_1 = require("../request");
const router_1 = require("../router");
const utils_1 = require("../utils");
function list() {
    return __awaiter(this, void 0, void 0, function* () {
        let pipelines = (yield request_1.get(`${router_1.route.pipeline}/list`)).rows;
        if (pipelines.length > 0) {
            console.table(pipelines, ['id', 'name', 'updatedAt', 'createdAt']);
        }
        else {
            console.info('no pipeline is created.');
        }
    });
}
function info(id) {
    return __awaiter(this, void 0, void 0, function* () {
        const pipeline = yield request_1.get(`${router_1.route.pipeline}/info/${id}`);
        console.info(JSON.stringify(pipeline, null, 2));
    });
}
function create(filename, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!path.isAbsolute(filename)) {
            filename = path.join(process.cwd(), filename);
        }
        const pipeline = yield request_1.post(`${router_1.route.pipeline}`, {
            config: filename,
            name: opts.name
        });
        utils_1.logger.success(`pipeline ${pipeline.id} created.`);
    });
}
function update(id, filename) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!path.isAbsolute(filename)) {
            filename = path.join(process.cwd(), filename);
        }
        const pipeline = yield request_1.put(`${router_1.route.pipeline}/${id}`, {
            config: filename
        });
        utils_1.logger.success(`pipeline ${pipeline.id} updated with ${filename}.`);
    });
}
function remove(id) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof id === 'string' && id !== 'all') {
            yield request_1.del(`${router_1.route.pipeline}/${id}`);
            utils_1.logger.success(`pipeline ${id} has removed.`);
        }
        else {
            const n = yield request_1.del(router_1.route.pipeline);
            utils_1.logger.success(`${n} pipelines has removed.`);
        }
    });
}
commander_1.default
    .command('list')
    .description('list all pipelines')
    .action(list);
commander_1.default
    .command('info <id>')
    .description('info the pipeline by its id')
    .action(info);
commander_1.default
    .command('create <file>')
    .description('create a pipeline')
    .option('-n|--name <name>', 'the pipeline name')
    .action(create);
commander_1.default
    .command('update <id> <filename>')
    .description('update a pipeline')
    .action(update);
commander_1.default
    .command('remove [id]')
    .description('remove all pipelines or specific 1 pipeline via id')
    .action(remove);
commander_1.default
    .command('install <pipeline>')
    .option('--verbose', 'prints verbose logs', true)
    .option('--tuna', 'use tuna mirror to install python packages')
    .action(pipeline_1.install)
    .description('install the plugins from a pipeline config file or url');
commander_1.default.parse(process.argv);
//# sourceMappingURL=pipcook-pipeline.js.map