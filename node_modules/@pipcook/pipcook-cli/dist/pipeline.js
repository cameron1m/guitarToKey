"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const zlib_1 = require("zlib");
const path_1 = require("path");
const tar_stream_1 = __importDefault(require("tar-stream"));
const utils_1 = require("./utils");
const config_1 = require("./config");
const router_1 = require("./router");
const request_1 = require("./request");
const fs_extra_1 = require("fs-extra");
function install(filename, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            filename = yield utils_1.parseConfigFilename(filename);
        }
        catch (err) {
            return utils_1.logger.fail(err.message);
        }
        const params = {
            cwd: utils_1.cwd(),
            config: filename,
            pyIndex: opts.tuna ? config_1.tunaMirrorURI : undefined
        };
        if (!opts.verbose) {
            request_1.get(`${router_1.route.pipeline}/install`, params);
            utils_1.logger.success(`install plugins succeeded.`);
            return;
        }
        else {
            return new Promise((resolve, reject) => {
                request_1.listen(`${router_1.route.pipeline}/install`, params, {
                    'log': (e) => {
                        const { level, data } = JSON.parse(e.data);
                        switch (level) {
                            case 'info':
                                utils_1.logger.info(data);
                                break;
                            case 'warn':
                                utils_1.logger.warn(data);
                                break;
                            default:
                                utils_1.logger.info(data);
                        }
                    },
                    'info': (e) => {
                        const { name, version } = JSON.parse(e.data);
                        utils_1.logger.start(`installing plugin ${name}@${version}`);
                    },
                    'installed': (e) => {
                        const { name, version } = JSON.parse(e.data);
                        utils_1.logger.success(`plugin (${name}@${version}) is installed`);
                    },
                    'error': (e) => {
                        utils_1.logger.fail(`occurrs an error ${e.data}`, false);
                        reject(new TypeError(e.data));
                    },
                    'finished': () => {
                        utils_1.logger.success('all plugins installed');
                        resolve();
                    }
                });
            });
        }
    });
}
exports.install = install;
function run(filename, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const cwd = process.cwd();
        utils_1.logger.start('start running the pipeline...');
        try {
            filename = yield utils_1.parseConfigFilename(filename);
        }
        catch (err) {
            return utils_1.logger.fail(err.message);
        }
        const params = {
            cwd,
            config: filename,
            pyIndex: opts.tuna ? config_1.tunaMirrorURI : undefined
        };
        if (!opts.verbose) {
            const job = yield request_1.get(`${router_1.route.job}/start`, params);
            utils_1.logger.success(`create job(${job.id}) succeeded.`);
        }
        else {
            let stdout, stderr;
            yield request_1.listen(`${router_1.route.job}/start`, params, {
                'job created': (e) => {
                    const job = JSON.parse(e.data);
                    utils_1.logger.success(`start running ${filename}...`);
                    stdout = utils_1.tail(job.id, 'stdout');
                    stderr = utils_1.tail(job.id, 'stderr');
                },
                'job finished': (e) => __awaiter(this, void 0, void 0, function* () {
                    const job = JSON.parse(e.data);
                    utils_1.logger.success(`job(${job.id}) is finished with ${e.data}`);
                    stdout === null || stdout === void 0 ? void 0 : stdout.kill();
                    stderr === null || stderr === void 0 ? void 0 : stderr.kill();
                    const outputRootPath = path_1.join(cwd, opts.output || 'output');
                    // remove the output dir
                    yield fs_extra_1.remove(outputRootPath);
                    // generate output
                    const extract = tar_stream_1.default.extract();
                    extract.on('entry', (header, stream, next) => __awaiter(this, void 0, void 0, function* () {
                        const dist = path_1.join(outputRootPath, header.name);
                        if (header.type === 'directory') {
                            yield fs_extra_1.mkdirp(dist);
                        }
                        else if (header.type === 'file') {
                            stream.pipe(fs_extra_1.createWriteStream(dist));
                        }
                        stream.on('end', next);
                        stream.resume();
                    }));
                    (yield request_1.getFile(`${router_1.route.job}/${job.id}/output.tar.gz`)).pipe(zlib_1.createGunzip()).pipe(extract);
                }),
                'error': (e) => {
                    utils_1.logger.fail(`occurrs an error ${e.data}`, false);
                    stdout === null || stdout === void 0 ? void 0 : stdout.kill();
                    stderr === null || stderr === void 0 ? void 0 : stderr.kill();
                    process.exit(1);
                }
            });
        }
    });
}
exports.run = run;
//# sourceMappingURL=pipeline.js.map